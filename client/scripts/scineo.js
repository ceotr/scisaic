// Generated by CoffeeScript 2.0.3
(function() {
  $(window).on("load", function() {
    var canvas, container, context, max_zoom, stage, starting_tile, starting_zoom, tileManager, tile_size, tms_url;
    tms_url = "tiles/{z}/{x}/{y}.png";
    starting_zoom = 0;
    max_zoom = 4;
    tile_size = 720;
    canvas = $('#plot');
    stage = new createjs.Stage(canvas[0]);
    starting_tile = tms_url.replace('{z}', starting_zoom).replace('{x}', '0').replace('{y}', '0');
    container = null;
    context = stage.canvas.getContext("2d");
    context.imageSmoothingEnabled = false;
    tileManager = {
      stage: stage,
      currentContainer: container,
      previousContainer: null,
      zoomLevel: starting_zoom,
      maxZoom: max_zoom,
      tmsUrl: tms_url,
      tileSize: tile_size,
      layerBounds: {
        width: null,
        height: null
      },
      addLayer: function(level = tileManager.zoomLevel) {
        var bounds, i, j, ref, ref1, tile, tileShape, url, x, y;
        tileManager.previousContainer = tileManager.currentContainer;
        tileManager.currentContainer = new createjs.Container();
        container = tileManager.currentContainer;
        tileManager.layerBounds.width = tileManager.layerBounds.height = tileManager.tileSize * (Math.pow(2, level));
        tileManager.currentContainer.setBounds(0, 0, tileManager.layerBounds.width, tileManager.layerBounds.height);
        stage.addChild(tileManager.currentContainer);
        bounds = stage.getBounds();
        tileShape = {
          x: 0,
          y: 0
        };
        for (x = i = 0, ref = Math.pow(2, level) - 1; 0 <= ref ? i <= ref : i >= ref; x = 0 <= ref ? ++i : --i) {
          for (y = j = 0, ref1 = Math.pow(2, level) - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; y = 0 <= ref1 ? ++j : --j) {
            url = tileManager.tmsUrl.replace('{z}', level).replace('{x}', x).replace('{y}', y);
            tile = new createjs.Bitmap(url);
            tile.set({
              x: x * tileManager.tileSize,
              y: y * tileManager.tileSize
            });
            tileManager.currentContainer.addChild(tile);
            tile.image.onload = function() {
              return stage.update();
            };
          }
        }
        if (tileManager.previousContainer !== null) {
          return tileManager.stage.removeChild(tileManager.previousContainer);
        }
      },
      // tileManager.previousContainer.visible = false
      nextLayer: function() {
        tileManager.zoomLevel += 1;
        return tileManager.replaceLayer();
      },
      previousLayer: function() {
        tileManager.zoomLevel -= 1;
        return tileManager.replaceLayer();
      },
      replaceLayer: function() {
        var newReg, oldLayerBounds, pc, previousBounds;
        // Before replacing the layer store any information which will be replaced
        previousBounds = tileManager.stage.getBounds();
        oldLayerBounds = $.extend({}, tileManager.layerBounds);
        // Load the new layer based on the stored zoomLevel
        tileManager.addLayer(tileManager.zoomLevel);
        // Convert the anchor point from the old layer and assign it to the new layer
        pc = tileManager.previousContainer;
        newReg = {
          x: (pc.regX / oldLayerBounds.width) * tileManager.layerBounds.width,
          y: (pc.regY / oldLayerBounds.height) * tileManager.layerBounds.height
        };
        tileManager.currentContainer.regX = newReg.x;
        tileManager.currentContainer.regY = newReg.y;
        // Convert the scale factors from the old layer and adjust the new layer to be the same size
        tileManager.currentContainer.scaleX = previousBounds.width / tileManager.layerBounds.width;
        tileManager.currentContainer.scaleY = previousBounds.height / tileManager.layerBounds.height;
        
        // Since the new layer is now the same size with the same anchor point as the old layer
        // the coordinates from the old layer can be directly assigned to the new layer
        tileManager.currentContainer.x = pc.x;
        tileManager.currentContainer.y = pc.y;
        return tileManager.stage.update();
      },
      zoom: function(e) {
        var bounds, local, zoom;
        // Function to handle scroll wheel zooming
        if (Math.max(-1, Math.min(1, e.wheelDelta || -e.detail || -e.deltaY)) > 0) {
          zoom = 1.1;
        } else {
          zoom = 1 / 1.1;
        }
        if ((tileManager.currentContainer.scaleX > 1.1 || tileManager.currentContainer.scaleY > 1.1) && zoom > 1) {
          if (tileManager.zoomLevel < tileManager.maxZoom) {
            return tileManager.nextLayer();
          }
        } else if ((tileManager.currentContainer.scaleX < 0.9 || tileManager.currentContainer.scaleY < 0.9) && zoom < 1) {
          if (tileManager.zoomLevel > 0) {
            return tileManager.previousLayer();
          }
        } else {
          // Get the current mouse position in local coordinates
          local = tileManager.currentContainer.globalToLocal(tileManager.stage.mouseX, tileManager.stage.mouseY);
          // Assign the local mouse position as the new anchor point so we can zoom around the mouse
          tileManager.currentContainer.regX = local.x;
          tileManager.currentContainer.regY = local.y;
          // move the view so that the mouse is centered
          tileManager.currentContainer.x = stage.mouseX;
          tileManager.currentContainer.y = stage.mouseY;
          // Double check that the user isn't zooming away from the plot
          bounds = stage.getBounds();
          if (bounds.width > tile_size || zoom > 1) {
            tileManager.currentContainer.scaleX *= zoom;
          }
          if (bounds.height > tile_size || zoom > 1) {
            tileManager.currentContainer.scaleY *= zoom;
          }
          return stage.update();
        }
      }
    };
    tileManager.addLayer();
    stage.addEventListener('stagemousedown', function(e) {
      var offset;
      // console.log "Yo"
      // console.log tileManager.stage.getBounds()
      // bounds = tileManager.currentContainer.getBounds()
      // console.log bounds
      // console.log tileManager.currentContainer.localToGlobal(bounds.x, bounds.y)
      // newBounds = tileManager.currentContainer.getBounds()
      // xRatio = tileManager.currentContainer.x / newBounds.width
      // yRatio = tileManager.currentContainer.y / newBounds.height
      // console.log(tileManager.currentContainer.x, tileManager.currentContainer.y)
      // console.log(xRatio, yRatio)
      offset = {
        x: container.x - e.stageX,
        y: container.y - e.stageY
      };
      stage.addEventListener("stagemousemove", function(ev) {
        container.x = ev.stageX + offset.x;
        container.y = ev.stageY + offset.y;
        return stage.update();
      });
      return stage.addEventListener("stagemouseup", function() {
        return stage.removeAllEventListeners("stagemousemove");
      });
    });
    return canvas[0].addEventListener('wheel', tileManager.zoom, false);
  });

}).call(this);
